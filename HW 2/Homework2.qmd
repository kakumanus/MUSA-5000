---
title: "Homework 2: Using Spatial Lag, Spatial Error and Geographically Weighted Regression to Predict Median House Values in Philadelphia Block Groups"
author: "Yiming Cao, Sujan Kakumanu, Angel Sanaa Rutherford"
date: October 30 2025
number-sections: true
execute:
  cache: true
format: pdf
---
```{r setup}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
options(scipen = 999)

# Packages
if(!require(pacman)){install.packages("pacman"); library(pacman, quietly = T)}
p_load(ggplot2, dplyr, sf, spdep, spgwr, tmap, spatialreg, whitestrap, lmtest, tseries, stargazer)

```

```{r read-files}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
Regression_shpData <- st_read("../HW 1/Lecture 1 - RegressionData.shp")
#regression_data <- read.csv("../HW 1/RegressionData.csv")
```

```{r variable-creation}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
# regression_data$LNMEDHVAL<-log(regression_data$MEDHVAL)
# 
# regression_data$LNPCTBACHMOR<-log(1+regression_data$PCTBACHMOR)
# regression_data$LNNBELPOV100<-log(1+regression_data$NBELPOV100)
# regression_data$LNPCTVACANT<-log(1+regression_data$PCTVACANT)
# regression_data$LNPCTSINGLES<-log(1+regression_data$PCTSINGLES)
```

```{r global-morans-weight-matrix}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hideplots/figures

queen<-poly2nb(Regression_shpData, row.names=Regression_shpData$POLY_ID)
summary(queen)

queenlist <- nb2listw(queen, style = 'W')

moran(Regression_shpData$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`

moranMC<-moran.mc(Regression_shpData$LNMEDHVAL, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
moranMC

moranMCres<-moranMC$res
hist(moranMCres, freq=10000000, nclass=100)   #Draws distribution of Moran's I's calculated from randomly permuted values
# Here, we draw a red vertical line at the observed value of our Moran's I
abline(v=moran(Regression_shpData$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`, col='red')  
```

```{r local-morans}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
lmoran<-localmoran(Regression_shpData$LNMEDHVAL, queenlist)
head(lmoran) # TODO: DO WE NEED MORE THAN THIS IN REPORT?
```

```{r ols-regression}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
reg1 <- lm(LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData)
summary(reg1)

logLik(reg1)

stdres <- rstandard(reg1)
Regression_shpData$standardised <- stdres

ggplot(Regression_shpData) +
  geom_sf(aes(fill =  stdres), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Standardized\nResiduals")+
  labs(
    title = "Map of Standardized Regression Residuals"
  ) +
  theme_void()+
  theme(
    plot.title = element_text(face = "bold", size=16, hjust = 0.7))
```

```{r spatially-lagged-residuals}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
wt_residu <- sapply(queen, function(x) mean(stdres[x]))

plot(wt_residu, stdres)

#Note the beta coefficient of the wt_residu. 0.73235. This suggests that there is spatial autocorrelation (areas with high residuals are near similar areas)
res.lm <- lm(formula=stdres ~ wt_residu)
summary(res.lm)

#Note the small p-value of Moran's I. Same spatial autocorrelation in the scatterplot.
moran.mc(stdres, queenlist, 999, alternative="two.sided")
moran.plot(stdres, queenlist)
```

```{r spatial-lag-reg}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures

lagreg<-lagsarlm(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData, queenlist)
summary(lagreg)

lagreg_res<-lagreg$residuals

lagMoranMc<-moran.mc(lagreg_res, queenlist,999, alternative="two.sided")
lagMoranMc

moran.plot(lagreg_res, queenlist)
```

```{r spatial-error-reg}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures

errreg<-errorsarlm(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData, queenlist)
summary(errreg)

errreg_res <- residuals(errreg)

errMoranMc<-moran.mc(errreg_res, queenlist,999, alternative="two.sided")
errMoranMc

moran.plot(errreg_res, queenlist)
```

```{r gwr-adaptive bandwidth}
#| echo: false

#Setting an adaptive bandwidth
shps <- as(Regression_shpData, 'Spatial')  #These analyses are easier to do when the data are of the SpatialPolygonsDataFrame class
class (shps)

# Bandwidth selection (optimal based on adaptive)
bw<-gwr.sel(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, 
            data=shps,
            method = "aic",
            adapt = TRUE)
bw
```

```{r gwr-fixed-bandwidth}
#| echo: false

bw_fixed<-gwr.sel(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, 
            data=shps,
            method = "aic",
            adapt = FALSE)
bw_fixed
```

```{r gwr-with-adaptive}
#| echo: false

gwrmodel<-gwr(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV,
              data=shps,
              adapt = bw, #adaptive bandwidth determined by proportion of observations accounted for
              gweight=gwr.Gauss,
              se.fit=TRUE, #to return local standard errors
              hatmatrix = TRUE)
gwrmodel
```

```{r gwr-with-fixed}
#| echo: false

gwrmodel_fixed<-gwr(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV,
              data=shps,
              bandwidth = bw_fixed, #fixed bandwidth
              gweight=gwr.Gauss,
              se.fit=TRUE, #to return local standard errors
              hatmatrix = TRUE)
gwrmodel_fixed
```

```{r map-local-r2}
#| echo: false

localR2 <- gwrmodel$SDF$localR2
localR2_sf <- st_as_sf(gwrmodel$SDF)

ggplot(localR2_sf) +
  geom_sf(aes(fill = localR2), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Local R²", limits = c(0, 1)) +
  labs(
    title = "Map of Local R² Values (GWR)",
  ) +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    legend.title = element_text(face = "bold")
  )
```

```{r gwr-morans}
#| echo: false

gwr_res <- gwrmodel$SDF$gwr.e

moran.plot(gwr_res, queenlist)

moran.mc(gwr_res, queenlist, 999, alternative="two.sided")

```

```{r gwr-coefficient-mapping}
#| echo: false

# --- 1. Extract GWR results ---
gwrresults <- as.data.frame(gwrmodel$SDF)

# --- 2. Convert your SpatialPolygonsDataFrame to sf ---
shps_sf <- st_as_sf(shps)

# --- 3. Compute standardized coefficients (coef / se) ---
shps_sf$coefPCTVACANT_st <- gwrresults$PCTVACANT / gwrresults$PCTVACANT_se
shps_sf$coefPCTSINGLES_st <- gwrresults$PCTSINGLES / gwrresults$PCTSINGLES_se
shps_sf$coefPCTBACHMOR_st <- gwrresults$PCTBACHMOR / gwrresults$PCTBACHMOR_se
shps_sf$coefLNNBELPOV_st <- gwrresults$LNNBELPOV / gwrresults$LNNBELPOV_se

# --- 4. Categorize coefficients according to your instructions ---
categorize_ratio <- function(x){
  cut(
    x,
    breaks = c(-Inf, -2, 0, 2, Inf),
    labels = c("dark red (< -2)", "pink (-2 to 0)", "light blue (0 to 2)", "dark blue (> 2)")
  )
}

shps_sf$coefPCTVACANT_cat <- categorize_ratio(shps_sf$coefPCTVACANT_st)
shps_sf$coefPCTSINGLES_cat <- categorize_ratio(shps_sf$coefPCTSINGLES_st)
shps_sf$coefPCTBACHMOR_cat <- categorize_ratio(shps_sf$coefPCTBACHMOR_st)
shps_sf$coefLNNBELPOV_cat <- categorize_ratio(shps_sf$coefLNNBELPOV_st)

# --- 5. Define manual colors ---
ratio_colors <- c(
  "dark red (< -2)" = "darkred",
  "pink (-2 to 0)" = "pink",
  "light blue (0 to 2)" = "lightblue",
  "dark blue (> 2)" = "darkblue"
)

# --- 6. Plot all predictors (example for PCTVACANT) ---
ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTVACANT_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTVACANT)") +
  labs(title = "Standardized GWR Coefficients for PCTVACANT") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTSINGLES_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTSINGLES)") +
  labs(title = "Standardized GWR Coefficients for PCTSINGLES") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTBACHMOR_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTBACHMOR)") +
  labs(title = "Standardized GWR Coefficients for PCTBACHMOR") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefLNNBELPOV_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (LNNBELPOV)") +
  labs(title = "Standardized GWR Coefficients for LNNBELPOV") +
  theme_minimal() +
  theme(legend.position = "right")

```

# Introduction (Google Doc at end)


# Methods

## The Concept of Spatial Autocorrelation (Angel)

## A Review of OLS Regression and Assumptions (Angel)

## Spatial Lag and Spatial Error Regression

The statistical programming language R was used to run spatial lag and spatial error regressions. 

The spatial lag regression model operates on the assumption that a dependent variable's value at any given location is associated by the values of that same variable at neighboring locations. To define spatial proximity in this analysis, we utilized a queen contiguity weight matrix W, which establishes neighboring relationships between any locations that share a border or vertex. The model equation for our spatial lag regression model is as follows:
$$
\begin{aligned}
\text{LNMEDHVAL} = &\rho W(\text{LNMEDHVAL}) + \beta_0 + \beta_1 \text{PCTVACANT} \\
&+ \beta_2 \text{PCTSINGLES} + \beta_3 \text{PCTBACHMOR} + \beta_4 \text{LNNBELPOV} + \varepsilon
\end{aligned}
$$
Here, $\rho$ is the coefficient of the y-lag variable W(LNMEDHVAL), which itself is the weighted average of log-transformed median house value at neighboring locations.  $\varepsilon$ represents the random variation not included in the model. The $\beta$ coefficients of the spatial lag models have a fairly complex interpretation which is beyond the scope of the report.

In contrast, the spatial error regression model relies on the assumption that the residual at one location is associated with residuals at nearby locations. As in the previously discussed spatial lag model, we will use a queen contiguity weight matrix W. The spatial error regression model is as follows:
$$
\begin{aligned}
\text{LNMEDHVAL} = &\beta_0 + \beta_1 \text{PCTVACANT} + \beta_2 \text{PCTSINGLES} \\
&+ \beta_3 \text{PCTBACHMOR} + \beta_4 \text{LNNBELPOV} + \lambda W(\varepsilon) + u
\end{aligned}
$$
Similar to OLS regression, $\beta_0$ represents the dependent variable when all predictors are zero. Also, the coefficients of the predictors $\beta_1, \beta_2, \beta_3, \beta_4$ each represent the change in the dependent variable with a one unit increase in their respective predictor, holding all other predictors constant. Uniquely, the error term is decomposed into a component with a spatial pattern $\lambda W(\varepsilon)$ and a random component $u$, where $\lambda$ is constrained between -1 and 1 and measures the strength of spatial dependence in the residuals.

It is important to note that all of the previously discussed assumptions of OLS regression are required for both spatial error and spatial lag models, with the exception of independence of observations. Both spatial models are specifically designed to address violations of this independence assumption by accounting for spatial autocorrelation. The goal if for these models to produce residuals free from spatial patterns that would otherwise indicate systematic over- or under-prediction.

The performance of both spatial models will be compared to that of the OLS regression from the previous report using multiple criteria. The first is the Akaike Information Criterion (AIC), which is an estimator of predictor error and provides insight into the quality of the model by penalizing increasing number of predictors that could lead to over-fitting. The lower the AIC, the better the fit of the model.

The second criterion is Log Likelihood, which measures model fit based on maximum likelihood estimation. A higher Log Likelihood indicates better model fit, though this metric can only compare nested models—models where removing parameters from one yields another. Both spatial lag and spatial error models are nested within OLS regression due to their additional spatial parameters, making them comparable to OLS but not to each other using Log Likelihood.

A third criterion is the Likelihood Ratio Test, which also comes with the restriction that it be used between nested models (i.e comparing OLS to a spatial model). The null hypothesis of this test is as follows:
$$
H_0: \text{The spatial model is not a better specification than the OLS model.} 
$$
When this test is conducted, if p < 0.05, we can reject $H_0$ and state that the spatial model is doing better than the OLS model.

Finally, the Moran's I statistic of the regression residuals can be compared across models. A Moran's I value near zero indicates that the model has successfully accounted for spatial autocorrelation. When comparing spatial models to OLS, insignificant values closer to zero suggest better correction of spatial dependence.

## Geographically Weighted Regression (Ming)


# Results

## Spatial Autocorrelation (Angel)

## A Review of OLS Regression and Assumptions: Results (Angel)

## Spatial Lag and Spatial Error Regression Results

### Spatial Lag Regression Results
The results of the Spatial Lag model are presented in Table 2 below.

```{r spatial-lag-reg-results}
#| label: tbl-spatial-lag
#| echo: false
#| tbl-pos: "H"
#| tbl-cap: "Spatial Lag Model Results"

lagreg <- lagsarlm(formula = LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, 
                   data = Regression_shpData, queenlist)
summary(lagreg)
```
The $\rho$ (rho) term, the spatial lag term, measures the influence of neighboring block group LNMEDHVAL on a given block's LNMEDHVAL. According to the results, this coefficient is 0.6511 and is very statistically significant with a p-value far less than our threshold of 0.05. This coefficient suggests that for a 1% increase in nearby block group house values, we can expect a 0.65% increase in a given block group's log-transformed Median House Value.

All four predictors (PCTVACANT, PCTSINGLES, PCTBACHMOR and LNNBELPOV) are statistically significant in the spatial lag model (all p-values are far less than 0.05). This indicates that each predictor has a meaningful relationship with log-transformed Median House Value even after accounting for spatial dependence. In particular, PCTVACANT and LNNBELPOV are associated with lower housing values, while PCTSINGLES and PCTBACHMOR are associated with higher values.

We can now compare these results to that of the OLS model from the prior report. The direction and significance of the predictors are consistent, though the spatial lag model yields smaller coefficients, suggesting that part of the variation previously attributed to these predictors is actually explained by the spatial lag term's inclusion of neighboring block group effects.

Below are the results of a Breusch-Pagan test on the Spatial Lag regression model.
```{r saptial-lag-bp-results}
#| echo: false
#| results: asis
cat("\\begin{center}\n")
print(bptest.Sarlm(lagreg, studentize = FALSE))
cat("\\end{center}\n")
```
Based on these results of the p-value far less than 0.05, we reject the null hypothesis of homoscedasticity. This indicates that even after accounting for spatial dependence in the spatial lag model, the residuals still exhibit heteroscedasticity—in other words, the variance of the errors is not constant across observations.

The spatial lag model fits the data substantially better than OLS, with a much lower AIC (525.48 vs. 1435), higher log-likelihood, and a highly significant Likelihood Ratio test (911.51, p-value far less than 0.05), indicating that accounting for spatial dependence improves model performance. However, the Breusch–Pagan test shows that residual heteroscedasticity remains, suggesting that further adjustments are needed.

To further investigate the spatial lag model's improvement over OLS, we can examine the Moran's I scatter plot of spatial lag regression residuals and a Monte-Carlo simulation of Moran's I.
```{r spatial-lag-morans-results}
#| echo: false
lagreg_res<-lagreg$residuals

lagMoranMc<-moran.mc(lagreg_res, queenlist,999, alternative="two.sided")
lagMoranMc

moran.plot(lagreg_res, queenlist)
```
Here, we see that the residuals from the Spatial Lag Model aren't significantly spatially auto correlated. Some weak negative autocorrelation remains as evidenced by the scatter plot, but overall the model has largely mitigated the spatial clustering present in OLS residuals.

Overall, with some room for improvement, the Spatial Lag Model appears to perform better than the OLS regression mode.

### Spatial Error Regression Results
The results of the Spatial Lag model are presented in Table 3 below.
```{r spatial-error-reg-results}
#| label: tbl-spatial-err
#| echo: false
#| tbl-pos: "H"
#| tbl-cap: "Spatial Error Model Results"

errreg<-errorsarlm(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData, queenlist)
summary(errreg)
```
As mentioned previously, the $\lambda$ (lambda) term measures the strength of spatial dependence in the residuals. According to the results, this coefficient is 0.8149 and is very statistically significant with a p-value far less than our threshold of 0.05. This coefficient indicates that approximately 81% of the spatial pattern in the residuals can be attributed to effects from neighboring block groups' residuals. In other words, after accounting for the predictors, unmeasured factors affecting log-transformed Median House Values in one block group are strongly correlated with those same unmeasured factors in neighboring block groups.

All four of the predictors (PCTVACANT, PCTSINGLES, PCTBACHMOR and LNNBELPOV) are also statistically significant in the Spatial Error model, all with p-values far less than 0.05. As mentioned in the methods section, interpreting the beta coefficients of Spatial Error Models is beyond the scope of this report.

We can compare the results of the Spatial Error model to that of the OLS model from the previous report. There are similar negative relationships between LNMEDHVAL and predictors PCTVACANT and LNNBELBOV, and positive relationships between LNMEDHVAL and predictors PCTSINGLES and PCTBACHMOR. Similar to the results in the Spatial Lag section, here the coefficients are smaller than that in the OLS model, suggesting that the Spatial Error term accounts for variation missing from the OLS model.

Below are the results of a Breusch-Pagan test on the Spatial Error regression model. 
```{r saptial-err-bp-results}
#| echo: false
#| results: asis
cat("\\begin{center}\n")
print(bptest.Sarlm(errreg, studentize = FALSE))
cat("\\end{center}\n")
```
With a p-value far less than 0.05 in the Breusch-Pagan test, we reject the null hypothesis of homoscedasticity. This shows that even for the Spatial Error model, the residuals still exhibit heteroscedasticity.

The Spatial Error model fits the data substantially better than OLS, with a much lower AIC (759.38 vs. 1435), higher log-likelihood, and a highly significant Likelihood Ratio test (677.61, p-value far less than 0.05), indicating that including the spatial error component improved model performance in comparison to OLS. Similar to the results from Spatial Lag, the results of the Breusch-Pagan test warrant further investigation to reduce heteroscedasticity.

To further investigate the Spatial Error model’s improvement over OLS, we can examine the Moran’s I scatter plot of spatial error regression residuals and a Monte-Carlo simulation of Moran’s I.
```{r spatial-error-morans-results}
#| echo: false
errreg_res <- residuals(errreg)

errMoranMc<-moran.mc(errreg_res, queenlist,999, alternative="two.sided")
errMoranMc

moran.plot(errreg_res, queenlist)
```
The residuals from the Spatial Error Model are not meaningfully spatially autocorrelated. The Moran’s I statistic of –0.0945 is near zero, and the scatter plot shows residuals with a very weak negative relationship. Although the test is statistically significant (p = 0.002), the near-zero Moran’s I value indicates that the model has effectively removed the spatial autocorrelation present in the OLS residuals.

Similar to the results from the Spatial Lag model, here we see the Spatial Error model perform better than OLS regression with room for improvement. Next, we can compare the two spatial models together.

### Comparing the Spatial Lag Model to the Spatial Error Model

The Spatial Lag Model has a substantially lower AIC (525.48 vs. 759.38), indicating it provides a better fit to the data. The difference of approximately 234 is quite large, strongly favoring the spatial lag model.
This suggests that the spatial dependence in log-transformed median home values is better captured by direct spillover effects from neighboring block group log-transformed median home values (the lag model) rather than by spatial error terms (the error model). In other words, a block group's log-transformed median home value is more directly influenced by the actual log-transformed median home values in surrounding block groups than by unmeasured spatially-structured factors.

## Geographically Weighted Regression Results (Ming)


# Discussion (Google Doc at end)