---
title: "Homework 2: Using Spatial Lag, Spatial Error and Geographically Weighted Regression to Predict Median House Values in Philadelphia Block Groups"
author: "Yiming Cao, Sujan Kakumanu, Angel Sanaa Rutherford"
date: October 30 2025
number-sections: true
execute:
  cache: true
  eval: false
format: pdf
---
```{r setup}
#| echo: false
#| results: "hide" # Hide the output
#| message: false  # Hide messages
#| warning: false  # Hide warnings
#| fig.show: "hide" # Hide plots/figures
options(scipen = 999)

# Packages
if(!require(pacman)){install.packages("pacman"); library(pacman, quietly = T)}
p_load(ggplot2, dplyr, sf, spdep, spgwr, tmap, spatialreg, whitestrap, lmtest, tseries)

```

```{r read-files}
#| echo: false
Regression_shpData <- st_read("../HW 1/Lecture 1 - RegressionData.shp")
#regression_data <- read.csv("../HW 1/RegressionData.csv")
```

```{r variable-creation}
#| echo: false
# regression_data$LNMEDHVAL<-log(regression_data$MEDHVAL)
# 
# regression_data$LNPCTBACHMOR<-log(1+regression_data$PCTBACHMOR)
# regression_data$LNNBELPOV100<-log(1+regression_data$NBELPOV100)
# regression_data$LNPCTVACANT<-log(1+regression_data$PCTVACANT)
# regression_data$LNPCTSINGLES<-log(1+regression_data$PCTSINGLES)
```

```{r global-morans-weight-matrix}
#| echo: false
queen<-poly2nb(Regression_shpData, row.names=Regression_shpData$POLY_ID)
summary(queen)

queenlist <- nb2listw(queen, style = 'W')

moran(Regression_shpData$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`

moranMC<-moran.mc(Regression_shpData$LNMEDHVAL, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
moranMC

moranMCres<-moranMC$res
hist(moranMCres, freq=10000000, nclass=100)   #Draws distribution of Moran's I's calculated from randomly permuted values
# Here, we draw a red vertical line at the observed value of our Moran's I
abline(v=moran(Regression_shpData$LNMEDHVAL, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`, col='red')  
```

```{r local-morans}
#| echo: false
lmoran<-localmoran(Regression_shpData$LNMEDHVAL, queenlist)
head(lmoran) # TODO: DO WE NEED MORE THAN THIS IN REPORT?
```
```{r ols-regression}
#| echo: false
reg1 <- lm(LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData)
summary(reg1)

logLik(reg1)

stdres <- rstandard(reg1)
Regression_shpData$standardised <- stdres

#| echo: false
ggplot(Regression_shpData) +
  geom_sf(aes(fill =  stdres), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Standardized\nResiduals")+
  labs(
    title = "Map of Standardized Regression Residuals"
  ) +
  theme_void()+
  theme(
    plot.title = element_text(face = "bold", size=16, hjust = 0.7))
```

```{r spatially-lagged-residuals}
#| echo: false
wt_residu <- sapply(queen, function(x) mean(stdres[x]))

plot(wt_residu, stdres)

#Note the beta coefficient of the wt_residu. 0.73235. This suggests that there is spatial autocorrelation (areas with high residuals are near similar areas)
res.lm <- lm(formula=stdres ~ wt_residu)
summary(res.lm)

#Note the small p-value of Moran's I. Same spatial autocorrelation in the scatterplot.
moran.mc(stdres, queenlist, 999, alternative="two.sided")
moran.plot(stdres, queenlist)
```

```{r spatial-lag-reg}
#| echo: false

lagreg<-lagsarlm(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData, queenlist)
summary(lagreg)

lagreg_res<-lagreg$residuals

lagMoranMc<-moran.mc(lagreg_res, queenlist,999, alternative="two.sided")
lagMoranMc

moran.plot(lagreg_res, queenlist)
```

```{r spatial-error-reg}
#| echo: false

errreg<-errorsarlm(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, data=Regression_shpData, queenlist)
summary(errreg)

errreg_res <- residuals(errreg)

errMoranMc<-moran.mc(errreg_res, queenlist,999, alternative="two.sided")
errMoranMc

moran.plot(errreg_res, queenlist)
```

```{r gwr-adaptive bandwidth}
#| echo: false

#Setting an adaptive bandwidth
shps <- as(Regression_shpData, 'Spatial')  #These analyses are easier to do when the data are of the SpatialPolygonsDataFrame class
class (shps)

# Bandwidth selection (optimal based on adaptive)
bw<-gwr.sel(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, 
            data=shps,
            method = "aic",
            adapt = TRUE)
bw
```

```{r gwr-fixed-bandwidth}
#| echo: false

bw_fixed<-gwr.sel(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV, 
            data=shps,
            method = "aic",
            adapt = FALSE)
bw_fixed
```

```{r gwr-with-adaptive}
#| echo: false

gwrmodel<-gwr(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV,
              data=shps,
              adapt = bw, #adaptive bandwidth determined by proportion of observations accounted for
              gweight=gwr.Gauss,
              se.fit=TRUE, #to return local standard errors
              hatmatrix = TRUE)
gwrmodel
```

```{r gwr-with-fixed}
#| echo: false

gwrmodel_fixed<-gwr(formula=LNMEDHVAL ~ PCTVACANT + PCTSINGLES + PCTBACHMOR + LNNBELPOV,
              data=shps,
              bandwidth = bw_fixed, #fixed bandwidth
              gweight=gwr.Gauss,
              se.fit=TRUE, #to return local standard errors
              hatmatrix = TRUE)
gwrmodel_fixed
```

```{r map-local-r2}
#| echo: false

localR2 <- gwrmodel$SDF$localR2
localR2_sf <- st_as_sf(gwrmodel$SDF)

ggplot(localR2_sf) +
  geom_sf(aes(fill = localR2), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Local R²", limits = c(0, 1)) +
  labs(
    title = "Map of Local R² Values (GWR)",
  ) +
  theme_void() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    legend.title = element_text(face = "bold")
  )
```
```{r gwr-morans}
#| echo: false

gwr_res <- gwrmodel$SDF$gwr.e

moran.plot(gwr_res, queenlist)

moran.mc(gwr_res, queenlist, 999, alternative="two.sided")

```

```{r gwr-coefficient-mapping}
#| echo: false

# --- 1. Extract GWR results ---
gwrresults <- as.data.frame(gwrmodel$SDF)

# --- 2. Convert your SpatialPolygonsDataFrame to sf ---
shps_sf <- st_as_sf(shps)

# --- 3. Compute standardized coefficients (coef / se) ---
shps_sf$coefPCTVACANT_st <- gwrresults$PCTVACANT / gwrresults$PCTVACANT_se
shps_sf$coefPCTSINGLES_st <- gwrresults$PCTSINGLES / gwrresults$PCTSINGLES_se
shps_sf$coefPCTBACHMOR_st <- gwrresults$PCTBACHMOR / gwrresults$PCTBACHMOR_se
shps_sf$coefLNNBELPOV_st <- gwrresults$LNNBELPOV / gwrresults$LNNBELPOV_se

# --- 4. Categorize coefficients according to your instructions ---
categorize_ratio <- function(x){
  cut(
    x,
    breaks = c(-Inf, -2, 0, 2, Inf),
    labels = c("dark red (< -2)", "pink (-2 to 0)", "light blue (0 to 2)", "dark blue (> 2)")
  )
}

shps_sf$coefPCTVACANT_cat <- categorize_ratio(shps_sf$coefPCTVACANT_st)
shps_sf$coefPCTSINGLES_cat <- categorize_ratio(shps_sf$coefPCTSINGLES_st)
shps_sf$coefPCTBACHMOR_cat <- categorize_ratio(shps_sf$coefPCTBACHMOR_st)
shps_sf$coefLNNBELPOV_cat <- categorize_ratio(shps_sf$coefLNNBELPOV_st)

# --- 5. Define manual colors ---
ratio_colors <- c(
  "dark red (< -2)" = "darkred",
  "pink (-2 to 0)" = "pink",
  "light blue (0 to 2)" = "lightblue",
  "dark blue (> 2)" = "darkblue"
)

# --- 6. Plot all predictors (example for PCTVACANT) ---
ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTVACANT_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTVACANT)") +
  labs(title = "Standardized GWR Coefficients for PCTVACANT") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTSINGLES_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTSINGLES)") +
  labs(title = "Standardized GWR Coefficients for PCTSINGLES") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefPCTBACHMOR_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (PCTBACHMOR)") +
  labs(title = "Standardized GWR Coefficients for PCTBACHMOR") +
  theme_minimal() +
  theme(legend.position = "right")

ggplot(shps_sf) +
  geom_sf(aes(fill = coefLNNBELPOV_cat), color = NA) +
  scale_fill_manual(values = ratio_colors, name = "Coef/SE (LNNBELPOV)") +
  labs(title = "Standardized GWR Coefficients for LNNBELPOV") +
  theme_minimal() +
  theme(legend.position = "right")

```

# Introduction (Google Doc at end)


# Methods

## The Concept of Spatial Autocorrelation (Angel)

## A Review of OLS Regression and Assumptions (Angel)

## Spatial Lag and Spatial Error Regression

The statistical programming language R was used to run spatial lag and spatial error regressions. 

The spatial lag regression model operates on the assumption that a dependent variable's value at any given location is associated by the values of that same variable at neighboring locations. To define spatial proximity in this analysis, we utilized a queen contiguity weight matrix W, which establishes neighboring relationships between any locations that share a border or vertex. The model equation for our spatial lag regression model is as follows:
$$
\begin{aligned}
\text{LNMEDHVAL} = &\rho W(\text{LNMEDHVAL}) + \beta_0 + \beta_1 \text{PCTVACANT} \\
&+ \beta_2 \text{PCTSINGLES} + \beta_3 \text{PCTBACHMOR} + \beta_4 \text{LNNBELPOV} + \varepsilon
\end{aligned}
$$
Here, $\rho$ is the coefficient of the y-lag variable W(LNMEDHVAL), which itself is the weighted average of log-transformed median house value at neighboring locations.  $\varepsilon$ represents the random variation not included in the model. The $\beta$ coefficients of the spatial lag models have a fairly complex interpretation which is beyond the scope of the report.

In contrast, the spatial error regression model relies on the assumption that the residual at one location is associated with residuals at nearby locations. As in the previously discussed spatial lag model, we will use a queen contiguity weight matrix W. The spatial error regression model is as follows:
$$
\begin{aligned}
\text{LNMEDHVAL} = &\beta_0 + \beta_1 \text{PCTVACANT} + \beta_2 \text{PCTSINGLES} \\
&+ \beta_3 \text{PCTBACHMOR} + \beta_4 \text{LNNBELPOV} + \lambda W(\varepsilon) + u
\end{aligned}
$$
Similar to OLS regression, $\beta_0$ represents the dependent variable when all predictors are zero. Also, the coefficients of the predictors $\beta_1, \beta_2, \beta_3, \beta_4$ each represent the change in the dependent variable with a one unit increase in their respective predictor, holding all other predictors constant. Uniquely, the error term is decomposed into a component with a spatial pattern $\lambda W(\varepsilon)$ and a random component $u$, where $\lambda$ is constrained between -1 and 1 and measures the strength of spatial dependence in the residuals.

It is important to note that all of the previously discussed assumptions of OLS regression are required for both spatial error and spatial lag models, with the exception of independence of observations. Both spatial models are specifically designed to address violations of this independence assumption by accounting for spatial autocorrelation. The goal if for these models to produce residuals free from spatial patterns that would otherwise indicate systematic over- or under-prediction.

The performance of both spatial models will be compared to that of the OLS regression from the previous report using multiple criteria. The first is the Akaike Information Criterion (AIC), which is an estimator of predictor error and provides insight into the quality of the model by penalizing increasing number of predictors that could lead to over-fitting. The lower the AIC, the better the fit of the model.

The second criterion is Log Likelihood, which measures model fit based on maximum likelihood estimation. A higher Log Likelihood indicates better model fit, though this metric can only compare nested models—models where removing parameters from one yields another. Both spatial lag and spatial error models are nested within OLS regression due to their additional spatial parameters, making them comparable to OLS but not to each other using Log Likelihood.

A third criterion is the Likelihood Ratio Test, which also comes with the restriction that it be used between nested models (i.e comparing OLS to a spatial model). The null hypothesis of this test is as follows:
$$
H_0: \text{The spatial model is not a better specification than the OLS model.} 
$$
When this test is conducted, if p < 0.05, we can reject $H_0$ and state that the spatial model is doing better than the OLS model.

Finally, the Moran's I statistic of the regression residuals can be compared across models. A Moran's I value near zero indicates that the model has successfully accounted for spatial autocorrelation. When comparing spatial models to OLS, insignificant values closer to zero suggest better correction of spatial dependence.

## Geographically Weighted Regression (Ming)


# Results

## Spatial Autocorrelation (Angel)

## A Review of OLS Regression and Assumptions: Results (Angel)

## Spatial Lag and Spatial Error Regression Results (Sujan)

## Geographically Weighted Regression Results (Ming)


# Discussion (Google Doc at end)